<!DOCTYPE html>
<html lang="en" xmlns:margin-left="http://www.w3.org/1999/xhtml">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Verification</title>

    <!-- Bootstrap core CSS -->
    <link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <link href="css/custom-styles.css" rel="stylesheet">

</head>

<body id="page-top">

<!-- Navigation -->
<nav class="navbar navbar-expand-lg navbar-dark bg-dark-semitransparent fixed-top" id="mainNav">
    <div class="container">
        <a class="navbar-brand js-scroll-trigger" href="index.html">Home</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarResponsive"
                aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarResponsive">
            <ul class="navbar-nav ml-auto">
                <li class="nav-item">
                    <a class="nav-link nav-pills" href="verification.html">Verification</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link nav-pills" href="futureWork.html">Future Work</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link nav-pills" href="otherProjects.html">Other Projects</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link nav-pills" href="aboutDominik.html">About Dominik</a>
                </li>
                <!--<li class="nav-item">
                    <a class="nav-link js-scroll-trigger" href="#field1">Cool navbar field 1</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link js-scroll-trigger" href="#field2">Field 2</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link js-scroll-trigger" href="#field3">Field 3</a>
                </li>-->
            </ul>
        </div>
    </div>
</nav>

<header class="verification-style">   <!--was bg-primary-->
    <div class="container">
        <div class="row">
            <div class="container col-lg-8 mx-auto padded-left">
                <h1 style="text-align: left; margin-left: 10px" class="padded-abit text-white">Specification and
                    Verification</h1>
            </div>
        </div>
    </div>
</header>

<section id="field1">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 mx-auto">
                <!--<h2>About smart contracts</h2>-->
                <p class="lead">Smart contracts are at the core of Dominik's research, more specifically how
                    they can be made safer.</p>
                <ul>
                    <li><a href="#field2">Overview of Smart Contracts</a></li>
                    <li><a href="#field3">Specification</a></li>
                    <li><a href="#field4">Verification</a></li>
                    <li><a href="#field5">Conclusion</a></li>
                </ul>
            </div>
        </div>
    </div>
</section>

<section id="field2" class="bg-light">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 mx-auto">
                <h2>Smart Contracts</h2>
                <p class="lead">In general contracts are required as a result of distrust between parties forming some
                    sort of
                    agreement. Smart contracts differ from classical contracts in that, they execute agreements on a
                    distributed ledger. Each ledger has it's own consensus protocol, which
                    ensures the correct execution of each smart contract. The capabilities of said contracts range from
                    restrictive to Turing-complete instruction sets. Bitcoin is an example of the former whereas
                    Ethereum is an example of the latter.
                </p>
                <h4>Technical overview</h4>
                <p class="lead">Smart contracts are made up of 4 main technical elements:</p>
                <p>
                    <b>High-level languages</b>
                    such as <i>Solidity</i> provide a way for developers to express desired contracts, there is no
                    limitation on how many
                    of these can exist in parallel on the same ledger.
                </p>
                <p>
                    <b>Intermediary representations (IR)</b> these
                    can be used to reason about properties or to optimise code an example is <i>Scilla</i>.
                </p>
                <p>
                    <b>Low-level languages</b> need to implement the contract in a deterministic fashion for it to be
                    executed on
                    a distributed virtual machine, Ethereum uses <i>EVM bytecode</i>.
                </p>
                <p>
                    The <b>Distributed ledger</b> plays a vital role in how the language is designed. The ledger can be
                    separated into
                    transaction and scripts, consensus protocol and network protocol.
                </p>
                <h4>Security properties</h4>
                <p class="lead">The two main desired properties of smart contracts are safety and liveness. Safety
                    referring to satisfying the correct properties during any state. Liveness, as in describing that
                    certain events may eventually occur. A formal definition of general security properties of a smart
                    contract include the following:
                </p>
                <p>
                    <b>Call integrity:</b> A contract's control flow should not be influenced by an opposing contract.
                    This could happen, since a specific contracts state may depend on an external call, which could
                    potentially change the global state or re-enter the contract causing a recursive loop.
                </p>
                <p>
                    <b>Atomicity:</b> Functions of a contract should either be fully executed or the state should be
                    reverted. However it should be noted that a contract could executed an external call successfully
                    and not terminate due to an issue, such a contract would be drained when sending currency.
                </p>
                <p>
                    <b>Independence:</b> Contracts should be independent of the global state and parameters, which can
                    be influenced externally. This is because miners and other parties paying higher fees can
                    potentially control some parameters.
                </p>
                <p>
                    <b>Runtime correctness</b> is also essential and can be ensured by defining the expected behaviour
                    of each particular contract, as each one serves a distinct purpose.
                </p>
            </div>
        </div>
    </div>
</section>

<section id="field3">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 mx-auto">
                <h2>Specification</h2>
                <img class="diagram" src="pics/specification.JPG">
                <p class="lead">There are many ways to specify a smart contract, the design of the specific language
                    chosen determines a lot of the security properties of the contract itself. These design aspects and
                    their properties are explored in the following subsections and a general overview of commonly used
                    languages is given:
                </p>
                <h4>Type</h4>
                <b>High-level</b>
                <p>The most widely used smart contract language is <i>Solidity</i>, this was created specifically for
                    Ethereum. Other examples of high-level languages used for smart contracts include: <i>Bamboo, Vyper,
                        Flint, Pyramid Scheme, Obsidian, Rholang, Liquidity, DAML, Pact</i>.
                </p>
                <!--<p>
                    <i>Bamboo</i>, which was created with formal verification in mind.
                </p>
                <p>
                    <i>Vyper</i> restricts instructions(no infinite or recursive loops, prevents inheritance and
                    overloading).
                </p>
                <p>
                    <i>Flint</i> introduces function access and asset types.
                </p>
                <p>
                    <i>Pyramid Scheme</i> is a functional and imperative language, it promotes separation of
                    state-changing and static functions.
                </p>
                <p>
                    <i>Obsidian</i> models contracts as finite state machines with explicit state transition functions.
                </p>
                <p>
                    <i>Rholang</i> focuses on concurrency and message-passing through statically typed communication
                    channels.
                </p>
                <p>
                    <i>Liquidity</i> has a restricted instruction set and enables formal verification.
                </p>
                <p>
                    <i>DAML</i> and <i>Pact</i> were developed for financial applications, both have a restricted
                    instruction set and promote formal verification.
                </p>-->
                <b>Intermediary</b>
                <p>
                    Examples of intermediary representations include: <i>Simplicity, Scilla, Yul, Solidity, EthIR,
                    IELE</i>.
                </p>
                <!--<p>
                    <i>Simplicity</i> is a pure functional language.
                </p>
                <p>
                    <i>Scilla</i> is also functional and has an automata-based design, using explicit state transitions
                    and handles communication patterns.
                </p>
                <p>
                    <i>Yul</i> was introduced as part of <i>Solidity</i>.
                </p>
                <p>
                    <i>EhtIR</i> is a decompilation target for EVM bytecode.
                </p>
                <p>
                    <i>IELE</i> is derived from its formal semantics.
                </p>-->
                <b>Low-level</b>
                <p>
                    Smart contracts are essentially stored on a distributed ledger in the form of a low-level language,
                    which is to be executed by the VM, examples of such languages: <i>Bitcoin script, EVM, eWASM,
                    Michelson</i>.
                </p>
                <b>General purpose languages</b>
                <p>
                    <i>Hyperledger Fabric</i> or <i>Neo</i> use general purpose programming languages. The advantage to
                    this is that they are already know to developers and previous verification tools can be used.
                    However the global state needs to imported through special functions, furthermore these languages
                    often allow infinite and recursive loops.
                </p>
                <h4>Paradigm</h4>
                <b>Explicit state transitions</b>
                <p>
                    Representing contracts as finite state machines (or automata)
                    prevents reentrancy and allows explicit state transition functions. Thus a transaction, which has
                    the intention to change the state is either successful or raises an exception. Furthermore using
                    this principle prevents any calls to external contracts within a transition function, so that states
                    do not change unpredictably.
                </p>
                <b>Functional programming</b>
                <p>
                    Functions in these languages can be designed in a way such that they either execute entirely or
                    revert. Other than pure functions, (which can be used to check that the local/global state isn't
                    affected) no other state-changing functions can be called.
                </p>
                <b>Logic programming</b>
                <p>
                    These languages closely resemble natural language contracts, and can be purposely non-deterministic
                    as they may transfer the burden of determinism to the low-level languages used (or the compiler).
                </p>
                <b>Stack-based</b>
                <p>
                    All low-level languages are stack-based. Their implementation make inspection of contracts
                    challenging, although automated tools can be used to help verification efforts, or decompilers can
                    be used to convert the stacks into higher-level languages.
                </p>
                <h4>Instructions</h4>
                <b>Restricted instructions</b>
                <p>
                    The idea behind restricting instructions is to prevent unwanted behavior, by only allowing necessary
                    operations. Mostly infinite loops and recursion are restricted.
                </p>
                <b>Tail-calls</b>
                <p>
                    A critical aspect of instructions is the ability to call other contracts, as this can potentially
                    lead to unpredictable state changes. State changes can be made explicit using tail-calls, which
                    prevents adversaries to gain access to the control flow of the contract.
                </p>
                <b>External function execution</b>
                <p>
                    External functions should be restricted, as they can grant storage access from the calling contract
                    to the called.
                </p>
                <b>Restrict overriding</b>
                <p>
                    Overriding can lead to issues with review, as it may not be trivial which code is being executed.
                </p>
                <b>Overflow</b>
                <p>
                    Is to be prevented, this can be done using fixed-length integers or arbitrary-precision signed
                    integers.
                </p>
                <b>Code re-use</b>
                <p>
                    Some languages re-use EVM code in order to optimise the space used by the code.
                </p>
                <h4>Semantics</h4>
                <b>Formal semantics</b>
                <p>
                    Creating formal semantics for a language can enable the creation of verified compilers, which would
                    make verification notably less challenging.
                </p>
                <b>Explicit types</b>
                <p>
                    The use of additional types can provide extra safety, for example enforcing updating the balance
                    before a function is called sending an asset.
                </p>
                <h4>Metering</h4>
                <b>Script size limit</b>
                <p>
                    <i>Bitcoin Script</i>, for example has a maximum script size of 10,000 bytes to restrict complexity.
                </p>
                <b>Gas</b>
                <p>
                    Gas considerations are important when making external and untrusted calls, as it raises the
                    possibility of out-of-gas errors. On the other hand, using a gas limit to restrict instructions
                    allows for liveness of the network by restricting denial of service attacks.
                </p>
                <h4>Additional Properties</h4>
                <b>Contract upgrades</b>
                <p>
                    Code is immutable in distributed ledgers, and so patterns which attempt to upgrade contracts cause
                    issues.
                </p>
                <b>Randomness</b>
                <p>
                    On distributed ledgers any local and global state needs to be deterministically verifiable by
                    anyone. Hence it is challenging to generate pseudo-random numbers, as miners can influence
                    parameters such as timestamps and hashes.
                    A proposed solution is verifiable delay functions.
                </p>
                <b>Secrets</b>
                <p>
                    Information needs to be verifiable, thus secrets are hard to implement. However commit-reveal
                    schemes and zero-knowledge proofs can be used to hide information, which is verifiable.
                </p>
                <b>Best practices</b>
                <p>
                    Templates can be used to create smart contracts and best practices should be applied, to prevent
                    unintended behaviours.
                </p>
            </div>
        </div>
    </div>
</section>

<section id="field4" class="bg-light">
    <div class="container">
        <div class="col-lg-8 mx-auto">
            <h2>Verification</h2>
            <img class="diagram" src="pics/verification.JPG">
            <p class="lead">There are three main approaches to smart contract verification. Approach (A) bases its
                analysis on the low-level code which is distributed on the ledger. Approach (B) decompiles the low-level
                code into an intermediary representation in order to reason about the properties of the contract.
                Finally, (C) reasons directly on the high-level code.</p>
            <h4>Approach</h4>
            <p class="lead">Any approach can be categorized in one of two classes:</p>
            <b>Proof-based verification</b>
            <p>
                In proof-based verification the system is represented by a set of formulas. These methods typically
                derive a formal definition of the specific distributed VM and then try to verify the properties of the
                contract.
            </p>
            <b>Model-based verification</b>
            <p>
                In this approach, the system being verified is a model. This approach builds a model directly from the
                smart contract and then tries to verify the expected properties, by using an implicit model of the given
                VM.
            </p>
            <h4>Automation</h4>
            <p class="lead">Can be either:</p>
            <b>Full automation</b>
            <p>
                This has a significant advantage as it uses many pre-defined properties which can be easily verified on
                other contracts. <b>Model-based</b> tools are fully automated, they mostly use an SMT solver to explore
                the
                potential fulfilment and violation of properties.
            </p>
            <b>Partial automation</b>
            <p>
                Partial automation can be used by defining properties that a specific contract should fulfill. However
                it is beneficial to first define the functionality of a contract and then verify it rather than finding
                selected vulnerabilities. <b>Proof-based methods</b> are partially automated.
            </p>
            <h4>Coverage</h4>
            <b>Partial, property-based verification</b>
            <p>
                Most <b>mode-based methods</b> verify only if selected properties are violated. The properties to be
                checked are based on set of known vulnerabilities, and contracts are flagged vulnerable if they conform
                to specific prior established patterns. These detections are made using static analysis.
            </p>
            <b>Full verification</b>
            <p>
                <b>Proof-based methods</b> aim to fully verify a contract, based on formally defined security semantics.
                However no security semantics are completed, as contract-specific properties are needed to ensure the
                correctness of a contract.
            </p>
            <h4>Languages</h4>
            <p>
                Majority of tools use <i>EVM bytecode</i> to derive a model of a contract. Moreover most models do not
                implement all of the opcodes, and so vulnerabilities can remain, hence not all contracts can be fully
                verified. There have been major work efforts to build a formal semantics of the EVM, none of which are
                fully complete. Some methods use <i>intermediary representations</i>, these should make future formal
                verification easier, as they are being designed with formal verification in mind. This approach further
                aids the development of verified compilers. <b>High-level language</b> are an exception as they build
                their model based on languages such as <i>Solidity</i> or <i>Java</i>.
            </p>
        </div>
    </div>
</section>

<section id="field5">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 mx-auto">
                <h2>Conclusion</h2>
                <p class="lead">To conclude the 4 main aspects which need to be taken into consideration to enable for
                    safer smart contracts are:</p>
                <h4>Language design</h4>
                <p>
                    <b>High-level languages</b> used for smart contracts can be designed in such a way that they promote
                    safety in
                    contracts by:
                <ul>
                    <li>Making state changes explicit through using an FSM/automata approach</li>
                    <li>Restricting the instruction set by only allowing finite loops</li>
                    <li>Preventing function overloading</li>
                    <li>Creating explicit types</li>
                    <li>Promoting pure functions</li>
                </ul>
                As an attempt to bring best practices from software engineering and language theory to distributed
                ledgers, <b>intermediary languages</b> are created with formal verification and optimisation in mind.
                <b>Low-level languages</b> allow formal verification and give a run-time optimised execution on the
                distributed ledger. Bringing all these practices together help create safer smart contracts.
                </p>
                <h4>Verification</h4>
                <p>
                    Contract verification efforts include:
                <ul>
                    <li>Categorising and defining security properties</li>
                    <li>Developing mode-based tools to prevent known bugs</li>
                    <li>Formal semantics to ensure compliance</li>
                </ul>
                <b>Proof-based verification</b> is more challenging than just checking for known vulnerabilities, thus
                it is only worthwhile for high-value contracts.
                </p>
                <h4>Formal semantics and verified compilers</h4>
                <p>
                    In the future it would be beneficial to adopt formal semantics in all language levels. Currently the
                    focus is developing IR's with formal semantics and and creating such semantics for already existing
                    low-level languages. This would simplify verification efforts and prevent ambiguities in code.
                    Moreover, the creation of verified compilers would be possible, which would make arguing about
                    contracts in high-level languages less challenging.
                </p>
                <h4>Complete security definitions</h4>
                <p>
                    General security definitions for various execution environments are required. Furthermore the
                    separation of the execution environment from the ledger, would open up the possibility of verifying
                    implementations against a formal specification. This could potentially pave the road for automated
                    formal verification.
                </p>
            </div>
        </div>
    </div>
</section>

<!-- Footer -->
<footer class="py-5 bg-dark">
    <div class="container">
        <p class="m-0 text-center text-white">Imperial College London </p>
    </div>
    <!-- /.container -->
</footer>

<!-- Bootstrap core JavaScript -->
<script src="vendor/jquery/jquery.min.js"></script>
<script src="vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

<!-- Plugin JavaScript -->
<script src="vendor/jquery-easing/jquery.easing.min.js"></script>

<!-- Custom JavaScript for this theme -->
<script src="js/scrolling-nav.js"></script>

</body>

</html>
