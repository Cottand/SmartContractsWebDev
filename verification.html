<!DOCTYPE html>
<html lang="en" xmlns:margin-left="http://www.w3.org/1999/xhtml">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Verification</title>

    <!-- Bootstrap core CSS -->
    <link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <link href="css/custom-styles.css" rel="stylesheet">

</head>

<body id="page-top">

<!-- Navigation -->
<nav class="navbar navbar-expand-lg navbar-dark bg-dark-semitransparent fixed-top" id="mainNav">
    <div class="container">
        <a class="navbar-brand js-scroll-trigger" href="index.html">Home</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarResponsive"
                aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarResponsive">
            <ul class="navbar-nav ml-auto">
                <li class="nav-item">
                    <a class="nav-link nav-pills" href="verification.html">Verification</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link nav-pills" href="futureWork.html">Future Work</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link nav-pills" href="otherProjects.html">Other Projects</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link nav-pills" href="aboutDominik.html">About Dominik</a>
                </li>
                <!--<li class="nav-item">
                    <a class="nav-link js-scroll-trigger" href="#field1">Cool navbar field 1</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link js-scroll-trigger" href="#field2">Field 2</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link js-scroll-trigger" href="#field3">Field 3</a>
                </li>-->
            </ul>
        </div>
    </div>
</nav>

<header class="verification-style">   <!--was bg-primary-->
    <div class="container">
        <div class="row">
            <div class="container col-lg-8 mx-auto padded-left">
                <h1 style="text-align: left; margin-left: 10px" class="padded-abit text-white">Specification and
                    Verification</h1>
            </div>
        </div>
    </div>
</header>

<section id="field1">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 mx-auto">
                <!--<h2>About smart contracts</h2>-->
                <p class="lead">Smart contracts are at the core of Dominik's research, more specifically how
                    they can be made safer.</p>
                <ul>
                    <li><a href="#field2">Overview of Smart Contracts</a></li>
                    <li><a href="#field3">Specification</a></li>
                    <li><a href="#field4">Verification</a></li>
                    <li><a href="#field5">Conclusion</a></li>
                </ul>
            </div>
        </div>
    </div>
</section>

<section id="field2" class="bg-light">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 mx-auto">
                <h2>Smart Contracts</h2>
                <p class="lead">In general contracts are required as a result of distrust between parties forming some
                    sort of
                    agreement. Smart contracts differ from classical contracts in that, they execute agreements on a
                    distributed ledger. Each ledger has it's own consensus protocol, which
                    ensures the correct execution of each smart contract. The capabilities of said contracts range from
                    restrictive to Turing-complete instruction sets. Bitcoin is an example of the former whereas
                    Ethereum is an example of the latter.
                </p>
                <h4>Technical overview</h4>
                <p class="lead">Smart contracts are made up of 4 main technical elements:</p>
                <p>
                    <b>High-level languages</b>
                    such as <i>Solidity</i> provide a way for developers to express desired contracts, there is no
                    limitation on how many
                    of these can exist in parallel on the same ledger.
                </p>
                <p>
                    <b>Intermediary representations (IR)</b> these
                    can be used to reason about properties or to optimise code an example is <i>Scilla</i>.
                </p>
                <p>
                    <b>Low-level languages</b> need to implement the contract in a deterministic fashion for it to be
                    executed on
                    a distributed virtual machine, Ethereum uses <i>EVM bytecode</i>.
                </p>
                <p>
                    The <b>Distributed ledger</b> plays a vital role in how the language is designed. The ledger can be
                    separated into
                    transaction and scripts, consensus protocol and network protocol.
                </p>
                <h4>Security properties</h4>
                <p class="lead">The two main desired properties of smart contracts are safety and liveness. Safety
                    referring to satisfying the correct properties during any state. Liveness, as in describing that
                    certain events may eventually occur. A formal definition of general security properties of a smart
                    contract include the following:
                </p>
                <p>
                    <b>Call integrity:</b> A contract's control flow should not be influenced by an opposing contract.
                    This could happen, since a specific contracts state may depend on an external call, which could
                    potentially change the global state or re-enter the contract causing a recursive loop.
                </p>
                <p>
                    <b>Atomicity:</b> Functions of a contract should either be fully executed or the state should be
                    reverted. However it should be noted that a contract could executed an external call successfully
                    and not terminate due to an issue, such a contract would be drained when sending currency.
                </p>
                <p>
                    <b>Independence:</b> Contracts should be independent of the global state and parameters, which can
                    be influenced externally. This is because miners and other parties paying higher fees can
                    potentially control some parameters.
                </p>
                <p>
                    <b>Runtime correctness</b> is also essential and can be ensured by defining the expected behaviour
                    of each particular contract, as each one serves a distinct purpose.
                </p>
            </div>
        </div>
    </div>
</section>

<section id="field3">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 mx-auto">
                <h2>Specification</h2>
                <p class="lead">There are many ways to specify a smart contract, the design of the specific language
                    chosen determines a lot of the security properties of the contract itself. These design aspects and
                    their properties are explored in the following subsections and a general overview of commonly used
                    languages is given:
                </p>
                <h4>Type</h4>
                <b>High-level</b>
                <p>The most widely used smart contract language is <i>Solidity</i>, this was created specifically for
                    Ethereum. Other examples of high-level languages used for smart contracts include: <i>Bamboo, Vyper,
                        Flint, Pyramid Scheme, Obsidian, Rholang, Liquidity, DAML, Pact</i>.
                </p>
                <!--<p>
                    <i>Bamboo</i>, which was created with formal verification in mind.
                </p>
                <p>
                    <i>Vyper</i> restricts instructions(no infinite or recursive loops, prevents inheritance and
                    overloading).
                </p>
                <p>
                    <i>Flint</i> introduces function access and asset types.
                </p>
                <p>
                    <i>Pyramid Scheme</i> is a functional and imperative language, it promotes separation of
                    state-changing and static functions.
                </p>
                <p>
                    <i>Obsidian</i> models contracts as finite state machines with explicit state transition functions.
                </p>
                <p>
                    <i>Rholang</i> focuses on concurrency and message-passing through statically typed communication
                    channels.
                </p>
                <p>
                    <i>Liquidity</i> has a restricted instruction set and enables formal verification.
                </p>
                <p>
                    <i>DAML</i> and <i>Pact</i> were developed for financial applications, both have a restricted
                    instruction set and promote formal verification.
                </p>-->
                <b>Intermediary</b>
                <p>
                    Examples of intermediary representations include: <i>Simplicity, Scilla, Yul, Solidity, EthIR,
                    IELE</i>.
                </p>
                <!--<p>
                    <i>Simplicity</i> is a pure functional language.
                </p>
                <p>
                    <i>Scilla</i> is also functional and has an automata-based design, using explicit state transitions
                    and handles communication patterns.
                </p>
                <p>
                    <i>Yul</i> was introduced as part of <i>Solidity</i>.
                </p>
                <p>
                    <i>EhtIR</i> is a decompilation target for EVM bytecode.
                </p>
                <p>
                    <i>IELE</i> is derived from its formal semantics.
                </p>-->
                <b>Low-level</b>
                <p>
                    Smart contracts are essentially stored on a distributed ledger in the form of a low-level language,
                    which is to be executed by the VM, examples of such languages: <i>Bitcoin script, EVM, eWASM,
                    Michelson</i>.
                </p>
                <b>General purpose languages</b>
                <p>
                    <i>Hyperledger Fabric</i> or <i>Neo</i> use general purpose programming languages. The advantage to
                    this is that they are already know to developers and previous verification tools can be used.
                    However the global state needs to imported through special functions, furthermore these languages
                    often allow infinite and recursive loops.
                </p>
                <h4>Paradigm</h4>
                <b>Explicit state transitions</b>
                <p>
                    Representing contracts as finite state machines (or automata)
                    prevents reentrancy and allows explicit state transition functions. Thus a transaction, which has
                    the intention to change the state is either successful or raises an exception. Furthermore using
                    this principle prevents any calls to external contracts within a transition function, so that states
                    do not change unpredictably.
                </p>
                <b>Functional programming</b>
                <p>
                    Functions in these languages can be designed in a way such that they either execute entirely or
                    revert. Other than pure functions, (which can be used to check that the local/global state isn't
                    affected) no other state-changing functions can be called.
                </p>
                <b>Logic programming</b>
                <p>
                    These languages closely resemble natural language contracts, and can be purposely non-deterministic
                    as they may transfer the burden of determinism to the low-level languages used (or the compiler).
                </p>
                <b>Stack-based</b>
                <p>
                    All low-level languages are stack-based. Their implementation make inspection of contracts
                    challenging, although automated tools can be used to help verification efforts, or decompilers can
                    be used to convert the stacks into higher-level languages.
                </p>
                <h4>Instructions</h4>
                <b>Restricted instructions</b>
                <p>
                    The idea behind restricting instructions is to prevent unwanted behavior, by only allowing necessary
                    operations. Mostly infinite loops and recursion are restricted.
                </p>
                <b>Tail-calls</b>
                <p>
                    A critical aspect of instructions is the ability to call other contracts, as this can potentially
                    lead to unpredictable state changes. State changes can be made explicit using tail-calls, which
                    prevents adversaries to gain access to the control flow of the contract.
                </p>
                <b>External function execution</b>
                <p>
                    External functions should be restricted, as they can grant storage access from the calling contract
                    to the called.
                </p>
                <b>Restrict overriding</b>
                <p>
                    Overriding can lead to issues with review, as it may not be trivial which code is being executed.
                </p>
                <b>Overflow</b>
                <p>
                    Is to be prevented, this can be done using fixed-length integers or arbitrary-precision signed
                    integers.
                </p>
                <b>Code re-use</b>
                <p>
                    Some languages re-use EVM code in order to optimise the space used by the code.
                </p>
                <h4>Semantics</h4>
                <b>Formal semantics</b>
                <p>
                    Creating formal semantics for a language can enable the creation of verified compilers, which would
                    make verification notably less challenging.
                </p>
                <b>Explicit types</b>
                <p>
                    The use of additional types can provide extra safety, for example enforcing updating the balance
                    before a function is called sending an asset.
                </p>
                <h4>Metering</h4>
                <b>Script size limit</b>
                <p>
                    <i>Bitcoin Script</i>, for example has a maximum script size of 10,000 bytes to restrict complexity.
                </p>
                <b>Gas</b>
                <p>
                    Gas considerations are important when making external and untrusted calls, as it raises the
                    possibility of out-of-gas errors. On the other hand, using a gas limit to restrict instructions
                    allows for liveness of the network by restricting denial of service attacks.
                </p>
                <h4>Additional Properties</h4>
                <b>Contract upgrades</b>
                <p>
                    Code is immutable in distributed ledgers, and so patterns which attempt to upgrade contracts cause
                    issues.
                </p>
                <b>Randomness</b>
                <p>
                    On distributed ledgers any local and global state needs to be deterministically verifiable by
                    anyone. Hence it is challenging to generate pseudo-random numbers, as miners can influence
                    parameters such as timestamps and hashes.
                    A proposed solution is verifiable delay functions.
                </p>
                <b>Secrets</b>
                <p>
                    Information needs to be verifiable, thus secrets are hard to implement. However commit-reveal
                    schemes and zero-knowledge proofs can be used to hide information, which is verifiable.
                </p>
                <b>Best practices</b>
                <p>
                    Templates can be used to create smart contracts and best practices should be applied, to prevent
                    unintended behaviours.
                </p>
            </div>
        </div>
    </div>
</section>

<section id="field4" class="bg-light">
    <div class="container">
        <div class="col-lg-8 mx-auto">
            <h2>Verification</h2>
            <p class="lead">TO COMPLETE</p>
            <h4>Approach</h4>
            <b>Proof-based verification</b>
            <p>

            </p>
            <b>Model-based verification</b>
            <p>

            </p>
            <h4>Automation</h4>
            <b>Full automation</b>
            <p>

            </p>
            <b>Partial automation</b>
            <p>

            </p>
            <h4>Coverage</h4>
            <b>Partial, property-based verification</b>
            <p>

            </p>
            <b>Full verification</b>
            <p>

            </p>
            <h4>Languages</h4>
            <p>

            </p>
        </div>
    </div>
</section>

<section id="field5">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 mx-auto">
                <h2>Conclusion</h2>

            </div>
        </div>
    </div>
</section>

<!-- Footer -->
<footer class="py-5 bg-dark">
    <div class="container">
        <p class="m-0 text-center text-white">Imperial College London </p>
    </div>
    <!-- /.container -->
</footer>

<!-- Bootstrap core JavaScript -->
<script src="vendor/jquery/jquery.min.js"></script>
<script src="vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

<!-- Plugin JavaScript -->
<script src="vendor/jquery-easing/jquery.easing.min.js"></script>

<!-- Custom JavaScript for this theme -->
<script src="js/scrolling-nav.js"></script>

</body>

</html>
